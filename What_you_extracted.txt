What you’re describing is basically an internal ticketing/request system with:35 requesters (employees)3 Accounts admins (see + act on all requests)1 Director (see everything + performance: open/closed, who closed, timestamps, etc.)Strict audit trail (who did what, when — server-recorded timestamps)Strong isolation (requesters can only see their own requests)Below is a “do it right” backend architecture that you can build using free tiers (and still keep security strong by enforcing access in the database, not in the UI).Best “free-tier + secure” stackRecommended (simplest + strongest isolation)Backend: Supabase (Postgres + Auth + RLS + Storage)Frontend: Next.js hosted on Cloudflare Pages (or Netlify)Why this is the best fit:Postgres Row-Level Security (RLS) lets you enforce “user only sees their own rows” at the database layer (this is exactly what you need).Supabase Auth gives login + JWT tokens that Postgres can use in RLS.Audit logging is easiest/cleanest in Postgres.Free tier reality check (important):Supabase Free includes 50,000 MAU, 500 MB database, 1 GB file storage, 5 GB egress, and free projects pause after 1 week of inactivity.Supabase Storage: for Free projects, the max file size limit can’t exceed 50 MB.Cloudflare Pages Free: 500 builds/month and static asset requests are free/unlimited; Pages Functions consume Workers free quotas (100k daily request limit is referenced in their Functions pricing doc).Note about VercelVercel’s Hobby plan is for personal, non-commercial use. For a company internal tool, that may push you to Pro.So if you want “free and ok for company”, Cloudflare Pages is usually the safer bet.Alternative (if you want only a free Postgres, but more backend work)Neon Postgres Free (serverless Postgres) + your own API + your own auth. Neon’s docs show a Free plan with 0.5 GB storage/project, etc.This can be great, but you’ll build more yourself.Backend architecture (the “no compromises” design)Core principle (this is non-negotiable)Never trust the frontend.Enforce all isolation and permissions in the backend (database policies), so even if someone hacks the UI, they still can’t read/update data they shouldn’t.For your app, the cleanest approach is:Postgres is the source of truthRLS enforces data isolationAppend-only audit log captures every meaningful change with server timestampsAdmins/director permissions are role-based (RBAC), stored in DBRoles & permissions matrixActionRequester (35)Accounts Admin (3)Director (1)Create request✅✅✅View own requests✅✅✅View everyone’s requests❌✅✅Add comment / additional info✅ (on own)✅✅Change status (open/in progress/closed)❌✅❌ (optional)Assign request to an admin❌✅❌See performance dashboard (SLA, who closed, time to close)❌✅ (optional)✅Manage roles (promote to admin etc.)❌❌ (optional)✅You can tweak, but this is a sane secure default.Data model (tables you should create)1) user_rolesStores each user’s role.user_id (uuid, PK, references auth.users.id)role enum: requester | accounts_admin | directorcreated_atcreated_by2) requests (current state)This is the “ticket”.id (uuid)created_at (server time)created_by (who raised it)titledescriptioncategory (invoice, reimbursement, vendor payment, etc.)priority (1–5)status enum: open | in_progress | waiting_on_requester | closedassigned_to (accounts admin user id, nullable)closed_at (server time)closed_by (who closed it)last_activity_at (server time, useful for director)last_activity_by3) request_events (append-only audit log)This is what your director really wants.id (bigint identity)request_idcreated_at (server time)actor_id (who performed action)event_type enum: created | comment | status_changed | assigned | closed | reopenedold_status, new_status (when relevant)note (optional)metadata jsonb (store changed fields snapshot, etc.)Rule: nobody can update/delete audit rows.4) request_commentsOptional separate table (recommended) so requesters can add info without editing the request record.idrequest_idcreated_atauthor_idbody5) request_attachmentsIf you need invoices/receipts.idrequest_iduploaded_atuploaded_bystorage_pathoriginal_filenamemime_typesize_bytes(And store the actual files in Supabase Storage; control access with policies + signed URLs.)Security design (how to guarantee isolation)A) Authentication (Supabase Auth)Use Supabase Auth with:email/password or Google OAuthConfirm Email enabledDisable open signups (invite-only), OR use a domain restriction hookSupabase Auth has general settings like “Allow new users to sign up” and “Confirm Email”.B) Restrict who can sign up (company-only)For internal company apps, you typically want:Only @yourcompany.com emails can existNo random signupsSupabase provides a “before-user-created” Auth Hook pattern including an example to restrict signups by email domain (exactly what you need).C) Email delivery (invites / magic links / confirmations)If you use email-based invites or confirmations, Supabase docs say you’ll need to configure a custom SMTP for delivery.(You can point this to your company SMTP or a third-party email provider.)D) Multi-factor authentication (MFA)For “strict security”, at minimum:Require MFA for Accounts Admin and DirectorSupabase supports MFA flows (TOTP/authenticator apps and phone-based).(Phone-based “advanced MFA” has extra usage costs; authenticator apps are the common choice.)The most important part: Postgres Row-Level Security policiesYou’ll do this:ALTER TABLE ... ENABLE ROW LEVEL SECURITY;Write policies so:Requesters can only SELECT rows where created_by = auth.uid()Accounts admins + director can SELECT everythingOnly accounts admins can UPDATE request status/assignmentRequesters can’t update requests (they add comments instead)This is how you get true isolation.“Time must be strictly noted” (server-side timestamps + audit)To avoid users faking timestamps, do not accept timestamps from the client.Instead:created_at DEFAULT now()triggers or controlled update functions that always set:updated_at = now()last_activity_at = now()event rows inserted with created_at = now()on closing:closed_at = now()closed_by = auth.uid()This guarantees:who created itwho updated itwho closed itexact server time for each actionSuggested implementation approach (very solid)Option 1 (recommended): DB-centric security + simple API usageFrontend calls Supabase directly with the user’s JWTRLS enforces permissionsUse triggers/functions for audit logging and status transitionsKey rule: never expose the Supabase service role key to the browser.Option 2: API-first (stricter control, more work)Next.js route handlers / server actions act as the APIThey pass the user JWT to Supabase, so RLS still appliesAdd extra validation, rate limits, etc.This is better if you expect complicated workflows later.Concrete SQL blueprint (starter schema + policies)Below is an MVP-grade schema layout (you’d run this in Supabase SQL editor). It shows the pattern; you can expand fields.This is intentionally “secure by default”: requesters can’t edit requests; they can only comment.-- Enumscreate type public.app_role as enum ('requester', 'accounts_admin', 'director');create type public.request_status as enum ('open', 'in_progress', 'waiting_on_requester', 'closed');create type public.request_event_type as enum ('created','comment','status_changed','assigned','closed','reopened');-- Roles tablecreate table public.user_roles (  user_id uuid primary key references auth.users(id) on delete cascade,  role public.app_role not null default 'requester',  created_at timestamptz not null default now());-- Requests table (current state)create table public.requests (  id uuid primary key default gen_random_uuid(),  created_at timestamptz not null default now(),  created_by uuid not null references auth.users(id),  title text not null,  description text not null,  category text not null,  priority int not null default 3 check (priority between 1 and 5),  status public.request_status not null default 'open',  assigned_to uuid null references auth.users(id),  closed_at timestamptz null,  closed_by uuid null references auth.users(id),  last_activity_at timestamptz not null default now(),  last_activity_by uuid null references auth.users(id));-- Append-only audit logcreate table public.request_events (  id bigint generated always as identity primary key,  request_id uuid not null references public.requests(id) on delete cascade,  created_at timestamptz not null default now(),  actor_id uuid not null references auth.users(id),  event_type public.request_event_type not null,  old_status public.request_status null,  new_status public.request_status null,  note text null,  metadata jsonb not null default '{}'::jsonb);-- Comments (requesters can add details here)create table public.request_comments (  id bigint generated always as identity primary key,  request_id uuid not null references public.requests(id) on delete cascade,  created_at timestamptz not null default now(),  author_id uuid not null references auth.users(id),  body text not null);-- Helper: role checkscreate or replace function public.has_role(_role public.app_role)returns booleanlanguage sqlstablesecurity definerset search_path = public, pg_tempas $$  select exists(    select 1    from public.user_roles ur    where ur.user_id = auth.uid()      and ur.role = _role  );$$;-- Enable RLSalter table public.user_roles enable row level security;alter table public.requests enable row level security;alter table public.request_events enable row level security;alter table public.request_comments enable row level security;-- Requests: SELECTcreate policy "requesters see own; admins/director see all"on public.requests for selectto authenticatedusing (  created_by = auth.uid()  or public.has_role('accounts_admin')  or public.has_role('director'));-- Requests: INSERT (any authenticated user can create)create policy "anyone can create request"on public.requests for insertto authenticatedwith check (  created_by = auth.uid());-- Requests: UPDATE (only accounts admins can update status/assignment)create policy "accounts admins can update requests"on public.requests for updateto authenticatedusing (public.has_role('accounts_admin'))with check (public.has_role('accounts_admin'));-- Audit log: SELECT only if you can see the requestcreate policy "read events if you can read request"on public.request_events for selectto authenticatedusing (  exists (    select 1    from public.requests r    where r.id = request_id      and (        r.created_by = auth.uid()        or public.has_role('accounts_admin')        or public.has_role('director')      )  ));-- Audit log: no direct writes from clients (we'll fill via triggers/functions)-- (Do NOT create insert/update/delete policies.)-- Comments: SELECT if can see the requestcreate policy "read comments if you can read request"on public.request_comments for selectto authenticatedusing (  exists (    select 1 from public.requests r    where r.id = request_id      and (        r.created_by = auth.uid()        or public.has_role('accounts_admin')        or public.has_role('director')      )  ));-- Comments: INSERT if requester owns the request or admin/directorcreate policy "write comments if you can read request"on public.request_comments for insertto authenticatedwith check (  exists (    select 1 from public.requests r    where r.id = request_id      and (        r.created_by = auth.uid()        or public.has_role('accounts_admin')        or public.has_role('director')      )  )  and author_id = auth.uid());Next step: add triggers that automatically insert into request_events whenever:a request is createdstatus changesassignment changescomment is addedThat gives your director the full “who did what when” timeline.Director dashboard (how to show “is Accounts doing work?”)Create database views like:open_requests_by_adminavg_time_to_first_updateavg_time_to_closestale_requests (no activity in X days)requests_closed_per_admin_per_weekSince you have created_at, last_activity_at, closed_at, and request_events, you can compute everything cleanly.Deployment flow (free)Create Supabase project (Free)Configure Auth:Confirm emailRestrict signup by domain using “before-user-created hook”Configure SMTP for invite/verification emailsApply SQL schema + RLSNext.js frontendSupabase has an official Next.js auth quickstart; also note they recommend the newer @supabase/ssr package over older auth helpersDeploy Next.js to Cloudflare Pages (free build limits apply)Hard security checklist (do these and you’ll be in a good place)✅ RLS enabled on every table containing business data✅ No service-role key in frontend (ever)✅ Disable public signups or domain-restrict signups✅ MFA for admins/director✅ Append-only audit log✅ No DELETE permissions on requests/audit (use status = closed)✅ Use server timestamps only (DB defaults/triggers)✅ Store attachments in storage with access policies; use signed URLs✅ Backups/log retention: free tiers are limited—if this is business-critical, plan a paid upgradeOne important “no-compromise” truthYou can build this securely on free tiers, but availability/compliance features (long backups, longer log retention, some SSO features) often require paid plans. For example, Supabase Team plan lists things like SOC2 and SSO for the Supabase dashboard.So: you can build the app correctly now, and later upgrade hosting once the tool becomes critical.If you want, I can also give you:a clean event/audit trigger function (so every change auto-logs),a director dashboard SQL view pack (open/closed, per-admin, SLA),and the exact page structure for Next.js (Requester portal vs Admin console vs Director dashboard).
